---
title: "Getting started with R and Python"
date: 2025-09-28
author: "Robin Szymanski"
format: html
embed-resources: true
---

## Getting started

### Name concepts of a programming language

> One concept of Python: Pass by reference (if you assign x=y, both x and y point to same object).
> Python also supports Duck Typing: Function accepts object based on behavior, not type. In R, type consistency is enforced (by tidyverse)
> Python is object-oriented and functional, while R focusses more on functional programming
> Both R and Python are interpreted (code runs without compiling before, as in C++ for example)

### Check operator precedence



 - Calculate `2 + 6 * 5 ^ 2`
 
```{r}
a <- 2 + (6 * 5^2)  # Cleaner version
b <- 2 + 6 * 5 ^ 2
print(a)
print(b)
```


 - Which operator has the higher priority?

::: unilur-solution
Exponentiation
Multiplication
Addition
::: 

 - Change the order of execution giving priority to `+`


```{r}
(2 + 6) * 5 ^ 2
```
 

### How to exchange two variables?

There are three ways (in Python) to exchange the values of the names!

```{python}
print("Version 1")
a = 5
b = 10
print(f"Before swap: a={a}, b={b}")

# Version 1
def swap_variables(x, y):
  return b, a
a, b = swap_variables(a, b)
print(f"After swap: a={a}, b={b}")

# Version 2
print("\nVersion 2")
a = 5
b = 10
print(f"Before swap: a={a}, b={b}")

tmp_list = list([a, b]) # Could also add .copy(), if unsure. Not sure if so clean this way.
a = tmp_list[1]
b = tmp_list[0]
print(f"After swap: a={a}, b={b}")

# Version 3
print("\nVersion 3")
a = 5
b = 10
print(f"Before swap: a={a}, b={b}")

# Hmm, limited time right now. I'd probably find a third way ;-)

```

### What is the output of the following code?

```{python}
x = 7
1 < x < 10 < x + 3 <= 13
```

Explain in your words!

On slide 20, we set x=7, and did four comparisons:
1) 1 < x: True, because 7 > 1
2) x < 10: True, because 7 < 10
3) 10 < x + 3: False, because 7 + 3 = 10, and this is equal to 10, not smaller
4) x + 3 <= 13: True, since 10 is < 13

=> Since all of the conditions have to be true, but one is false, the whole output is false, since
these four comparisons are basically concatenated by an "and".

::: unilur-solution
Python parses four expressions, 1 < x and x < 10 and 10 < x + 3 and x + 3 <= 13 [ ] True or [ ] False 
:::


### Missing values

A group of people in the street were asked about their age and answered `18, 20, 34, 53, 12, NA, NA, 72, 75, 13`.


::: {.callout-tip}
### Tip
You can use the function `replace()` to substitute `NA` with `0`.

Consider `is.na()` to identify indices of missing positions.
:::

 * Compute the average age. 
 
 * Replace NAs with 0. 
 
 * How large is error that you make when ignore missing values?

```{r}
people_age <- c(18, 20, 34, 53, 12, NA, NA, 72, 75, 13)
avrg_age_ignore_NA <- mean(people_age, na.rm=TRUE)
avrg_age_ignore_NA

people_age_NA_replaced_zero <- replace(people_age, is.na(people_age), 0)
avrg_age_NA_replaced_zero <- mean(people_age_NA_replaced_zero)

# Bonus: Replace with median value (better than 0, but in this case not a good
# solution since the data set is pretty small)
median_age <- median(people_age, na.rm=TRUE)
people_age_NA_replaced_median <- replace(people_age, is.na(people_age), median_age)
avrg_age_NA_replaced_median <- mean(people_age_NA_replaced_median)

error_ignore_vs_replace_zero <- avrg_age_ignore_NA - avrg_age_NA_replaced_zero
error_ignore_vs_replace_median <- avrg_age_ignore_NA - avrg_age_NA_replaced_median

cat("Average age - ignoring missing values:", avrg_age_ignore_NA)
cat("\nAverage age - replacing missing values by 0:", avrg_age_NA_replaced_zero)
cat("\nAverage age - replacing missing values by median:", avrg_age_NA_replaced_median)
cat("\nError - Ignore vs. replace by 0:", error_ignore_vs_replace_zero)
cat("\nError - Ignore vs. replace by 0:", error_ignore_vs_replace_median)

# If you really have to replace the values in such a small data set, it's better 
#to replace by median or mean (median more robust)
```

### Create a data frame

Create a data frame containing the following information:
  name |age |weight |  eye| group
Paul  | 16  | 57.0 |green  |   1
 Mary  |16   |50.0  |blue   |  1
 Sara  |16   |52.6 |black   |  2
 John  |17   |65.3 | blue    | 2

```{r}
classroom = data.frame(
  name=c("Paul", "Mary", "Sara", "John"), 
  age=c(16L, 16L, 16L, 17L), 
  weight=c(57.0, 50.0, 52.6, 65.3),
  eye=c("green", "blue", "black", "blue"),
  group=c(1L, 1L, 2L, 2L)
  )

# Alternative: tibble
# library(tibble)
# tbl <- tibble(
#   name=c("Paul", "Mary", "Sara", "John"), 
#   age=c(16, 16, 16, 17), 
#   weight=c(57.0, 50.0, 52.6, 65.3),
#   eye=c("green", "blue", "black", "blue"),
#   group=c(1, 1, 2, 2)
# )
# tbl


# There are probably more elegant ways to do it, like using for loops over all 
# columns, or even better: dedicated functions (like 'str' below), but I will do it manually
# for each column for now, since we haven't seen the tools, yet.

#print("Output of classroom data frame:")
#classroom
print("Types of classroom variables")
cat("Atomic:", is.atomic(classroom), "\n")
cat("Type of 'name' column:", typeof(classroom$name), "\n")
cat("Type of 'age' column:", typeof(classroom$age), "\n")
cat("Type of 'weight' column:", typeof(classroom$weight), "\n")
cat("Type of 'eye' column:", typeof(classroom$eye), "\n")
cat("Type of 'group' column:", typeof(classroom$group), "\n")

#str(classroom)   # Faster and better. Gives good overview plus datatypes


```

Assign the data frame to a variable named `classroom`.
-> See above

Describe the type of variables in `classroom`.
-> See above

Which data structure would you use in base Python?

```{python}
# If it is not base Python, I would you pandas dataframes, of course.
# But in base Python, I will use dictionaries with lists for the elements. Dictionaries come shortly
# after the question slide. If dictionaries are not allowed, I could use just lists. Let's do both

classroom_dict = {
  "name": ["Paul", "Mary", "Sara", "John"], # Lists, no tuples, since more flexible (mutable)
  "age": [16, 16, 16, 17], 
  "weight": [57.0, 50.0, 52.6, 65.3],
  "eye": ["green", "blue", "black", "blue"],
  "group": [1, 1, 2, 2]
}

print(classroom_dict)

classroom_list = [
  ["name", "age", "weight", "eye", "group"],
  ["Paul", 16, 57.0, "green", 1],
  ["Mary", 16, 50.0, "blue", 1]
  #...    # And so on, you get the point
  ]
print(classroom_list)

```



## `mtcars`

You will work with the built-in `mtcars` dataset (R) and a Python equivalent derived from it. The goal is to compare the capabilities of R and Python, highlighting their strengths and differences in data processing.


### Setup

- For R, use the `mtcars` dataset (built-in).
- For Python, use a dictionary-based equivalent of `mtcars`.
- Only use **base R** and **base Python**.

### Notes

- Focus on **readability** and **reproducibility** in your code.
- Provide brief comments explaining your code and comparisons between R and Python.
- Use `#` for comments in both languages to explain your reasoning.
- Highlight differences in syntax, ease of use, and language strengths in your comparisons.

## Python `mtcars` equivalent

Run this R code to represent `mtcars` data frame:
```{r}
head(mtcars, 10)
```

Run this Python code to create a dictionary mimicking `mtcars`:

```{python}
mtcars = {
    'mpg':  [21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,
             16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, 30.4, 33.9, 21.5, 15.5,
             15.2, 13.3, 19.2, 27.3, 26.0, 30.4, 15.8, 19.7, 15.0, 21.4],
    'cyl':  [6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6,
             8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,
             8, 8, 8, 4, 4, 4, 8, 6, 8, 4],
    'disp': [160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 167.6, 167.6,
             275.8, 275.8, 275.8, 472.0, 460.0, 440.0, 78.7, 75.7, 71.1, 120.1, 318.0,
             304.0, 350.0, 400.0, 79.0, 120.3, 95.1, 351.0, 145.0, 301.0, 121.0],
    'hp':   [110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123,
             180, 180, 180, 205, 215, 230, 66, 52, 65, 97, 150,
             150, 245, 175, 66, 91, 113, 264, 175, 335, 109],
    'drat': [3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,
             3.07, 3.07, 3.07, 2.93, 3.00, 3.23, 4.08, 4.93, 4.22, 3.70, 2.76,
             3.15, 3.73, 3.08, 4.08, 4.43, 3.77, 4.22, 3.62, 3.54, 4.11],
    'wt':   [2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.440, 3.440,
             4.070, 3.730, 3.780, 5.250, 5.424, 5.345, 2.200, 1.615, 1.835, 2.465, 3.520,
             3.435, 3.840, 3.845, 1.935, 2.140, 1.513, 3.170, 2.770, 3.570, 2.780],
    'qsec': [16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18.30, 18.90,
             17.40, 17.60, 18.00, 17.98, 17.82, 17.42, 19.47, 18.52, 19.90, 20.01, 16.87,
             17.30, 15.41, 17.05, 18.90, 16.70, 16.90, 14.50, 15.50, 14.60, 18.60],
    'vs':   [0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1,
             0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,
             0, 0, 0, 1, 0, 1, 0, 0, 0, 1],
    'am':   [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
             0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
             0, 0, 0, 1, 1, 1, 1, 1, 1, 1],
    'gear': [4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4,
             3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,
             3, 3, 3, 4, 5, 5, 5, 5, 5, 4],
    'carb': [4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4,
             3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,
             2, 4, 2, 1, 2, 2, 4, 6, 8, 2],
    'name': ['Mazda RX4', 'Mazda RX4 Wag', 'Datsun 710', 'Hornet 4 Drive', 'Hornet Sportabout',
             'Valiant', 'Duster 360', 'Merc 240D', 'Merc 230', 'Merc 280', 'Merc 280C',
             'Merc 450SE', 'Merc 450SL', 'Merc 450SLC', 'Cadillac Fleetwood', 'Lincoln Continental',
             'Chrysler Imperial', 'Fiat 128', 'Honda Civic', 'Toyota Corolla', 'Toyota Corona',
             'Dodge Challenger', 'AMC Javelin', 'Camaro Z28', 'Pontiac Firebird', 'Fiat X1-9',
             'Porsche 914-2', 'Lotus Europa', 'Ford Pantera L', 'Ferrari Dino', 'Maserati Bora',
             'Volvo 142E']
}
```


## Tasks

### Task 1: Basic operations

Using `mtcars` (R) and the provided dictionary (Python):

#### **Arithmetic operations**:

- In R, calculate the average `mpg` for cars with `cyl == 6` using **vectorized** operations.
   
```{r}
# Creating a subset for all cars with 6 cylinders, and only the mpgg column
mpg_cyl_6 <- subset(mtcars, cyl==6, select=c(mpg)) # select=mpg works equivalently

mean_mpg_cyl_6 <- mean(mpg_cyl_6$mpg, na_rm=FALSE) # Alternative: Replace NAs by median, but 1) only 7 rows, 2) no NAs in data
cat("Mean of mpg column for 6 cylinders:", mean_mpg_cyl_6)
```

- In base Python, calculate the same quantity.

```{python}
# Create subsets
list_cyl = mtcars["cyl"]
list_mpg = mtcars["mpg"]


# === Method 1: List comprehension ===  Note: I used this before I looked at slides of Key-value data

# Create a mask
mask = [i==6 for i in list_cyl]   # We did not have it, yet, but I can't think of another way right now.

# Apply the mask to get values of mpg for 6 cylinders
list_mpg_cyl_6 = [i for i,k in zip(list_mpg, mask) if k==True]

# Calculate mean
if len(list_mpg_cyl_6) != 0:
  mean_mpg_cyl_6 = sum(list_mpg_cyl_6)/len(list_mpg_cyl_6)
  # Print results
  print(f"Method 1: Mean of mpg column for 6 cylinders: {mean_mpg_cyl_6:0.2f}")
else:
  print("Division by zero.")




# Method 2: for-loop

# Select entries for 6 cylinders in mpg column
list_mpg_cyl_6 = []
for i in range(0, len(list_cyl)):
  if list_cyl[i] == 6:
    list_mpg_cyl_6.append(list_mpg[i])
  
# Calculate mean
if len(list_mpg_cyl_6) != 0:
  mean_mpg_cyl_6 = sum(list_mpg_cyl_6)/len(list_mpg_cyl_6)
  # Print results
  print(f"Method 2: Mean of mpg column for 6 cylinders: {mean_mpg_cyl_6:0.2f}")
else:
  print("Division by zero.")


# There are many more methods

```



#### **Comparison and logical operations**:
- In R, count the number of cars where `mpg > 20` and `hp <= 100` using vectorized logical operations.

```{r}
df_sub = subset(mtcars, (mpg > 20) & (hp <= 100))   # Filtering
cat("Number of cars where `mpg > 20` and `hp <= 100`:", length(df_sub$cyl))   # Number of rows
```

- In Python, perform the same operation.

```{python}
# Using method 2 from above

list_hp = mtcars["hp"]
list_mpg = mtcars["mpg"]

# Apply filter and count at same time
count = 0
for i in range(0, len(list_mpg)):
  if (list_mpg[i] > 20) and (list_hp[i] <= 100):
    count += 1  # Increase counter
    
print(f"Number of cars where 'mpg > 20' and 'hp <= 100': {count}")
```



### Task 2: Data types and structures

#### **Type checking and coercion**:
- In R, check the type of `mtcars$mpg` and coerce it to integer.

```{r}
cat("Type of mtcars$mpg column before coercion:", typeof(mtcars$mpg), "\n") # If you execute it a second time, it will output integer, because value was saved
mtcars$mpg <- as.integer(mtcars$mpg)
cat("Type of mtcars$mpg column after coercion:", typeof(mtcars$mpg), "\n")
```

- In Python, check the type of `mtcars['mpg']` and coerce it to a list of integers.

 
```{python}
print(f"Type of mtcars['mpg'] before coercion: {type(mtcars['mpg'][0])}")

# Convert elements of list to integer
mtcars['mpg'] = [int(i) for i in mtcars['mpg']]   # Or by for-loop, which is the same

print(f"Type of mtcars['mpg'] after coercion: {type(mtcars['mpg'][0])}")
```


#### **Subsetting/slicing**:
- In R, subset `mtcars` to select rows where `gear == 4` and columns `mpg`, and `hp`.

```{r}
df_sub <- subset(mtcars, gear==4, select=c(mpg, hp))
df_sub
```

- In Python, perform the same operation using explicit iteration.

```{python}

# Create empty dictionary for subset
df_sub = {
  "mpg": [],
  "hp": []
}

# Filter for gear = 4 and create subset
for i in range(0, len(mtcars['gear'])):
  if mtcars['gear'][i] == 4:
    df_sub["mpg"].append(mtcars['mpg'][i])
    df_sub["hp"].append(mtcars['hp'][i])

df_sub

# Note: The values in the mpg column are different from the R, because mpg was converted to int before for the Python code
```



### Task 3: Packages and libraries

#### **Loading packages/libraries**:
- In R, load the `tidyverse` package and use `dplyr::filter()` to select cars with `am == 1` (manual transmission).

```{r}
# I can't see it in the slides, yet, so I assume we don't have to do it, but I'll try anyway by the R documentation in RStudio
library(tidyverse)

#starwars %>% filter(skin_color == "light", eye_color == "brown")
# is equivalent to
# starwars[starwars$skin_color == "light" & starwars$eye_color == "brown", ]
# in R base code. Thus

mtcars %>% filter(am == 1)

```

- In Python, import the `statistics` module and calculate the mean `mpg` for cars with `am == 1`.
```{python}
# Also not in slides. Brief look into library. it seems like a statistical library.
# Thus filtering remains the same as before. I should have created a function for filtering.

import statistics

list_am = mtcars["am"]
list_mpg = mtcars["mpg"]

list_mpg_for_am_1 = []
for i in range(0, len(list_am)):
  if list_am[i] == 1:
    list_mpg_for_am_1.append(list_mpg[i])
    
statistics.mean(list_mpg_for_am_1)

# Caution: mpg was converted to int before!
```



